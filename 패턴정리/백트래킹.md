# 백트래킹 템플릿 모음

아래 템플릿들은 **`elements`** 와 결과를 담을 **`result`** 리스트를 전역 변수로 사용하며, 함수 인수로는 **`path`**, **`start/idx`**, 그리고 (순열에서만) **`used`** 만 전달하는 방식입니다. `append`/`pop` 대신 **새 리스트**를 생성해 넘기는 순수 함수형 스타일로 구현되어 있어, 전역 `result`에 바로 저장합니다.

---

## 1. 조합 (Combination)

원소 리스트 `elements`에서 크기 `k`인 모든 조합을 구합니다.

```python
# 전역 변수 선언
elements = [1, 2, 3, 4, 5]
result = []  # 완성된 조합을 저장할 리스트

# 함수 정의
def backtrack_comb(start, k, path):
    # 종료 조건: path 길이가 k와 같으면 전역 result에 추가
    if len(path) == k:
        result.append(path)
        return

    # 가능한 선택지 순회
    for i in range(start, len(elements)):
        backtrack_comb(i + 1, k, path + [elements[i]])

# 사용 예시
k = 3
backtrack_comb(0, k, [])
print(result)  # [[1,2,3], [1,2,4], … , [3,4,5]]
```

---

## 2. 순열 (Permutation)

`elements`의 모든 순열을 구합니다.

```python
# 전역 변수 선언
elements = [1, 2, 3]
result = []  # 완성된 순열을 저장할 리스트

# 함수 정의
def backtrack_perm(path, used):
    # 종료 조건: path 길이가 elements와 같으면 전역 result에 추가
    if len(path) == len(elements):
        result.append(path)
        return

    for i in range(len(elements)):
        if not used[i]:
            used[i] = True
            backtrack_perm(path + [elements[i]], used)
            used[i] = False

# 사용 예시
used = [False] * len(elements)
backtrack_perm([], used)
print(result)  # [[1,2,3], [1,3,2], [2,1,3], … ]
```

---

## 3. 부분집합 (Subset / Power Set)

`elements`의 모든 부분집합을 구합니다.

```python
# 전역 변수 선언
elements = [1, 2, 3]
result = []  # 완성된 부분집합을 저장할 리스트

# 함수 정의
def backtrack_subset(idx, path):
    # 종료 조건: 모든 인덱스를 고려했으면 전역 result에 추가
    if idx == len(elements):
        result.append(path)
        return

    # 1) elements[idx] 포함 경로
    backtrack_subset(idx + 1, path + [elements[idx]])
    # 2) elements[idx] 제외 경로
    backtrack_subset(idx + 1, path)

# 사용 예시
backtrack_subset(0, [])
print(result)  # [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
```
